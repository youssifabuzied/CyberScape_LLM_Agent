import json
import re
import argparse
import os
import subprocess
import json
from langchain.chat_models import ChatOpenAI
from langchain.schema import SystemMessage, HumanMessage
from Utils import read_file

# NEW: Import the Pydantic output parser and related classes
from langchain.output_parsers import PydanticOutputParser
from pydantic import RootModel
from typing import Dict

import sys
import codecs

sys.stdout = codecs.getwriter("utf-8")(sys.stdout.detach())


class LowLevelPlan(RootModel[Dict[str, str]]):
    """Mapping of phase numbers (as strings) to low-level instruction blocks."""


# ---------- Helper Functions for LLM Prompting ----------

def get_example_output(target):
    """Return the target-specific example output."""
    if target.upper() == "DRONE":
        return (
            "Drone.move_to_point((100.0,200.0,50.0))\n"
            "Drone.scan_area()\n"
            "if Drone.scan_successful():\n"
            "    Drone.send_data_to_apm()"
        )
    elif target.upper() == "ROBOT_DOG":
        return (
            "RobotDog.move_to(100.0,200.0)\n"
            "RobotDog.scan_area()\n"
            "RobotDog.send_data_to_apm()"
        )
    else:
        return ""


def build_phases_text(phases):
    """
    Builds a text representation of all phases.
    Each phase is listed with its number, state, phase target, inputs, and outputs.
    """
    phases_text = ""
    for phase in phases:
        phases_text += f"Phase {phase['phase_number']}:\n"
        phases_text += f"  State: {phase['state']}\n"
        phases_text += f"  Phase Target: {phase['phase_target']}\n"
        phases_text += f"  Inputs: {phase['inputs']}\n"
        phases_text += f"  Outputs: {phase['outputs']}\n\n"
    return phases_text


def get_target_rules(target):
    """Return the rules for the target as a string."""
    if target.upper() == "DRONE":
        return (
            """
            - ONLY use the functions provided in the specification for the drone. Do not invent or assume additional functions.
            - NO while loops and NO recursive calls.
            - Each phase must be independent, executing only after the previous phase completes.
            - If the drone needs to wait, explicitly include an idle state.
            - You are responsible for the translation of the high-level plan of the drone into a low-level set of executable drone instructions using ONLY the provided instructions. You won't be doing anything for the robot dog.  
            - You can use the set of Input variables for a given phase for the functions if needed. However, you should place the variables between those symboles <>. For example, Drone.move_to(<x>, <y>)
            """
        )
    elif target.upper() == "ROBOT_DOG":
        return (
            """
            - ONLY use the functions provided in the specification for the robot dog. Do not invent or assume additional functions.
            - NO while loops and NO recursive calls.
            - Each phase must be independent, executing only after the previous phase completes.
            - If the robot dog needs to wait, explicitly include an idle state.
            - Every movement must be verified using `if RobotDog.has_reached(X, Y):` before proceeding.
            - You are responsible for the translation of the high-level plan of the robot dog into a low-level set of executable robot dog instructions using ONLY the provided instructions. You won't be doing anything for the drone.  
            - You can use the set of Input variables for a given phase and pass them when calling the functions you use in the low-level plan if needed. However, you should place the variables between those symboles <>. For example, Drone.move_to(<x>, <y>)
            """
        )
    else:
        return ""


def generate_low_level_for_plan(llm, mission_text, phases, robot_spec, target):
    """
    Makes a single LLM call for all phases for the given target.
    The prompt includes:
      - The original mission text,
      - A structured list of high-level phases,
      - The robot specifications,
      - Target-specific rules and an example output.
    The LLM is instructed to output a JSON object mapping phase numbers (as strings)
    to the low-level instruction block for that phase.
    """
    example_output = get_example_output(target)
    phases_text = build_phases_text(phases)
    rules = get_target_rules(target)

    # NEW: Initialize the output parser with our Pydantic model.
    parser = PydanticOutputParser(pydantic_object=LowLevelPlan)
    format_instructions = parser.get_format_instructions()

    prompt = f"""

You are responsible for translating a high-level mission plan generated by an LLM for a robot to achieve a certain mission (there could be another robot in the mission, with another high-level plan that will separately also be translated to a low-level plan as well). Below are the relevant details. 

Original Mission:
{mission_text}

Robot specifications for {target}:
{robot_spec}

Below is the initial plan that has the high-level instructions for the {target} plan. In each phase, "State" represents the current status of the mission, "Phase Target" represents the high-level objective for that phase (which you will be translating into a set of low-level instructions), and there can be "Inputs" (variables that might be needed, along with their types) as well as "Outputs" that might be used by subsequent phases:
{phases_text}

Rules for the plan generation:
{rules}

Example Output for {target} (for one phase):
{example_output}

Please follow these format instructions:
{format_instructions}

Output a JSON object where each key is the phase number (as a string) and each value is the low-level instruction block for that phase. Don't output any other text. Make sure that the instructions follow the format provided in the example (instructions start with "RobotDog." for the robot dog, and "Drone." for the drone). 
    """
    print("LLM Prompt:\n", prompt)  # For debugging

    response = llm.invoke([
        SystemMessage(content="You are a helpful assistant."),
        HumanMessage(content=prompt)
    ])

    # Print raw LLM response before processing
    print("\nâš¡ LLM Raw Response:\n", response.content)

    # NEW: Use the parser to extract the structured output.
    try:
        parsed_output = parser.parse(response.content)
        instructions_json = parsed_output.model_dump()
    except Exception as e:
        raise ValueError(f"ðŸš¨ Error parsing JSON output from LLM: {e}\nResponse Content:\n{response.content}")

    print("\nâœ… Parsed Instructions JSON:\n", json.dumps(instructions_json, indent=2))  # Debugging

    return instructions_json


def update_plan_with_low_level(mission_plan, instructions_json, target):
    """
    For the given target, update each phase in the mission plan with the corresponding low-level instructions.
    Each low_level_plan will be stored as a list of instruction lines.
    """
    target_key = "drone_plan" if target.upper() == "DRONE" else "robot_dog_plan"
    for phase in mission_plan[target_key]["phases"]:
        phase_num = str(phase["phase_number"])
        if phase_num in instructions_json:
            # Split the instructions by newline so they become a list
            instructions = instructions_json[phase_num]
            if isinstance(instructions, str):
                phase["low_level_plan"] = instructions.splitlines()
            else:
                phase["low_level_plan"] = instructions
        else:
            phase["low_level_plan"] = []
    return mission_plan[target_key]


# ---------- Helper Functions for Verification and Parsing Steps ----------

def low_level_plan_to_text(phases):
    """
    Convert the list of phases (each with its "low_level_plan" attribute) into a clean, readable text format.
    Each phase is output as:
      Phase {number}:
      {low_level_plan}  <-- each instruction on a new line.
    """
    text = ""
    for phase in phases:
        # If the low_level_plan is a list, join it with actual newlines.
        instructions = phase.get("low_level_plan", "")
        if isinstance(instructions, list):
            instructions = "\n".join(instructions)
        text += f"Phase {phase['phase_number']}:\n{instructions}\n\n"
    return text


def parse_parsed_plan_text(text):
    """
    Parse the verified and parsed plan text (which should include lines like "Phase {number}:")
    into a dictionary mapping phase numbers (as strings) to instruction blocks.
    """
    pattern = re.compile(r"Phase (\d+):\s*(.*?)(?=Phase \d+:|$)", re.DOTALL)
    result = {}
    for match in pattern.finditer(text):
        phase_num = match.group(1).strip()
        instructions = match.group(2).strip()
        result[phase_num] = instructions
    return result


def run_subprocess_command(command, shell=True,
                           cwd=r"\\wsl.localhost\Ubuntu\home\zein\Uni\Thesis\CyberScape_LLM_Agent"):
    """Runs a command using subprocess and waits for it to complete."""
    print(f"Running command: {command}")
    result = subprocess.run(command, shell=True)
    if result.returncode != 0:
        raise RuntimeError(f"Command failed with return code {result.returncode}")


# ---------- Main Function ----------

def main():
    parser_arg = argparse.ArgumentParser(
        description="Generate low-level plans for a specified target (DRONE or ROBOT_DOG) from a high-level mission plan with verification and parsing steps."
    )
    parser_arg.add_argument("target", help="Target robot type: 'DRONE' or 'ROBOT_DOG'")
    args = parser_arg.parse_args()

    with open("config.json", "r") as f:
        config = json.load(f)

    mission_plan_file = config["mission_plan_file"]
    mission_text_file = config["mission_text_file"]
    if args.target == "ROBOT_DOG":
        spec_file = config["dog_spec_file"]
        output_file = config["dog_output_file"]
    else:
        spec_file = config["drone_spec_file"]
        output_file = config["drone_output_file"]

    # Read the high-level mission plan JSON
    with open(mission_plan_file, "r") as f:
        mission_plan = json.load(f)

    # Read the original mission text and the robot specifications
    mission_text = read_file(mission_text_file)
    spec = read_file(spec_file)

    # Determine the key for the target's plan and retrieve its phases
    target_key = "drone_plan" if args.target.upper() == "DRONE" else "robot_dog_plan"
    phases = mission_plan[target_key]["phases"]

    # OpenAI API Key
    OPENAI_API_KEY = config.get("openai_api_key", "")

    # Initialize the LLM with configurable options
    llm = ChatOpenAI(
        # Option 1: Meta-Llama-3.1-405B-Instruct
        # api_key=os.getenv("LLAMA_API_KEY"),
        # base_url="https://api.sambanova.ai/v1",
        # model_name="Meta-Llama-3.1-405B-Instruct",
        # temperature=0.1

        # Option 2: GPT-4O-Mini
        model_name="gpt-4o",
        openai_api_key=OPENAI_API_KEY,
        temperature=0.1

        # Option 3: Gemini-2.0-Flash
        # model_name="geminconfigi-2.0-flash",
        # google_api_key=os.getenv("GOOGLE_API_KEY"),
        # temperature=0.1
    )

    # --------- Step 1: Generate Low-Level Instructions ---------
    instructions_json = generate_low_level_for_plan(llm, mission_text, phases, spec, args.target)
    updated_target_plan = update_plan_with_low_level(mission_plan, instructions_json, args.target)

    # --------- Step 2: Verification Step ---------
    # Convert the low-level plan for the target into text
    low_level_text = low_level_plan_to_text(updated_target_plan["phases"])
    if args.target == "ROBOT_DOG":
        temp_plan_file = config["dog_temp_low_level_plan"]
    else:
        temp_plan_file = config["drone_temp_low_level_plan"]

    with open(temp_plan_file, "w") as f:
        f.write(low_level_text)

    # Call the Verification_Module on the low-level plan text
    # This assumes your Verification_Module.py has been adapted to work with low-level plan text
    verification_command = f"python Verification_Module.py {args.target}"
    run_subprocess_command(verification_command, shell=True,
                           cwd=r"\\wsl.localhost\Ubuntu\home\zein\Uni\Thesis\CyberScape_LLM_Agent")

    # --------- Step 3: Parsing Step ---------
    # Call the plan_parser on the verified plan text to clean/parse it
    parsing_command = f"python Plan_Parser.py {args.target}"
    run_subprocess_command(parsing_command, shell=True,
                           cwd=r"\\wsl.localhost\Ubuntu\home\zein\Uni\Thesis\CyberScape_LLM_Agent")
    # Get the output of plan_parser
    if args.target == "ROBOT_DOG":
        parsed_file = config["dog_parsed_plan_file"]
    else:
        parsed_file = config["drone_parsed_plan_file"]

    with open(parsed_file, "r") as f:
        parsed_text = f.read()

    print("Parsed Text for Debugging:", parsed_text)
    # Parse the text output into a dictionary mapping phase numbers to instructions
    parsed_instructions = parse_parsed_plan_text(parsed_text)

    # Update the JSON plan with the parsed instructions
    for phase in updated_target_plan["phases"]:
        phase_num = str(phase["phase_number"])
        if phase_num in parsed_instructions:
            phase["low_level_plan"] = parsed_instructions[phase_num]
        else:
            phase["low_level_plan"] = ""

    # --------- Final Step: Write the Final JSON Output ---------
    with open(output_file, "w") as f:
        json.dump(updated_target_plan, f, indent=4)

    print(f"Final verified and parsed low-level plan for {args.target.upper()} written to {output_file}")


if __name__ == "__main__":
    main()
